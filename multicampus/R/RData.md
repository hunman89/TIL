## R 데이터

[참고](https://thebook.io/006723/)

#### 변수

> 다양한 형태 존재한다. (스칼라, 벡터, 리스트, 행렬, 배열, 데이터 프레임)

* R의 변수명은 알파벳, 숫자, _(언더스코어), .(마침표)로 구성되며, -(하이픈)은 사용할 수 없다. 
* 첫 글자는 알파벳 또는 .으로 시작해야 한다. 만약 .으로 시작한다면 . 뒤에는 숫자가 올 수 없다. 



#### 변수값 할당

* <- , <<- 로 한다. ( = 와 <- 는 같은 의미이지만 = 는 제약이 있기 때문에 <- 만 사용)



#### 스칼라

> 단일 차원의 값

* 숫자

* NA(not available) : 값이 없는것 (0이 아니다.)

  ```R
  > z <- NA;
  > is.na(z)				# NA 값 확인
  [1] TRUE
  ```

  

* NULL: 값이 초기화되지 않았을때 사용, 프로그래밍의 편의를 위해 미정값 (undefined)

  ```r
  is_even <- NULL
    if (a 가 짝수면) {
       is_even <- TRUE
    } else {
       is_even <- FALSE
    }
  ```

* 문자열

  ```r
  > a <- "hello"
  > print(a)
  [1] "hello"
  ```

* 진리값 (TRUE, FALSE)

* Factor (범주형 데이터)

  ```R
  > sex <- factor("m", c("m", "f"))			# 2가지 값만 가능하게 설정, 여러가지 가능
  > sex
  [1] m
  Levels: m f
  ```



#### 벡터

> 다른 프로그래밍 언어에서 '배열'

* 한가지 스칼라 타입의 데이터를 저장

* Slice (자르기)

* 생성

  ```R
  > (x <- c(1, 2, 3, 4, 5))
  > x
  [1] 1 2 3 4 5
  ```

* 색인 부여 가능

  ```R
  > v1 <- c(1,2,3)
  > names(v1) <- c("d1","d2","d3")
  > v1
  d1 d2 d3 
   1  2  3 
  > 
  ```

* 접근

  ```R
  > v1[c(1,3)]				# 2개 이상의 경우 c() 이용해야 한다.
  d1 d3 
   1  3 
  
  > v1[1:3]
  d1 d2 d3 
   1  2  3 
  
  > v1[c(-1,-3)]
  d2 
   2 
  
  > v1["d1"]
  d1 
   1 
  
  > v1[c("d1","d3")]
  d1 d3 
   1  3
  
  > names(v1)[2]
  [1] "d2"
  
  > names(v1)[c(2,3)]
  [1] "d2" "d3"
  ```

* length() : 길이

* NROW() :  행 또는 열의 수

  * nrow는 행렬만 가능

* identical() : 동일여부

* union() : 합집합

* intersect() : 교집합

* setdiff() : 차집합

* setequall(): 동일집합

* 연산자

  ```r
  > v2 <- v1+v1			# 한꺼번에 일어남
  > v2
  d1 d2 d3 
   2  4  6 
  ```

* seq

  ```r
  > seq(3, 7)     # 1씩 증가
  [1] 3 4 5 6 7
  > seq(7, 3)     # 1씩 감소
  [1] 7 6 5 4 3
  > seq(3, 7, 2)  # 2씩 증가
  [1] 3 5 7
  > seq(3, 7, 3)  # 3씩 증가
  [1] 3 6
  
  > 3:7
  [1] 3 4 5 6 7
  ```

* rep

  ```r
  > rep(1:2, times=5)
  [1] 1 2 1 2 1 2 1 2 1 2
  > rep(1:2, each=5)
  [1] 1 1 1 1 1 2 2 2 2 2
  
  > rep(1:2, each=5, times=2)
  [1] 1 1 1 1 1 2 2 2 2 2 1 1 1 1 1 2 2 2 2 2
  ```

  

#### 리스트

> 해시테이블과 비슷 (key, value)

* 생성

  ```r
  > list1 <- list(v1 = "data1", v2 = "data2")
  > list1
  $`v1`
  [1] "data1"
  
  $v2
  [1] "data2"
  
  ```

* 접근

  ```r
  > list1$v1
  [1] "data1"
  
  > list1[1]
  $`v1`
  [1] "data1"
  ```

  

#### 행렬

> 한가지 유형의 스칼라만 저장할 수 있다.

* 생성

  ```r
  > matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow=3)
       [,1] [,2] [,3]
  [1,]    1    4    7
  [2,]    2    5    8
  [3,]    3    6    9
  
  > matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow=3, byrow=TRUE)
       [,1] [,2] [,3]
  [1,]    1    2    3
  [2,]    4    5    6
  [3,]    7    8    9
  
  > matrix(1:9, nrow=3, dimnames=list(c("r1", "r2", "r3"), c("c1", "c2", "c3")))
     c1 c2 c3
  r1  1  4  7
  r2  2  5  8
  r3  3  6  9
  
  > x <- matrix(1:9, ncol=3)
  > rownames(x) 							 # 행 이름이 없으므로 NULL이 반환됨
  NULL
  > rownames(x) <- c("r1", "r2", "r3")
  > x
     [,1] [,2] [,3]
  r1    1    4    7
  r2    2    5    8
  r3    3    6    9
  > colnames(x) <- c("c1", "c2", "c3")
  > x
      c1 c2 c3
  r1   1  4  7
  r2   2  5  8
  r3   3  6  9
  ```

* 접근

  ```r
  > x[1,1]
  [1] 1
  
  > x[1:2, ]
      [,1] [,2] [,3]
  [1,]   1    4    7
  [2,]   2    5    8
  
  > x[-3, ]
       [,1] [,2] [,3]
  [1,]    1    4    7
  [2,]    2    5    8
  
  > x[c(1, 3), c(1, 3)]
       [,1] [,2]
  [1,]    1    7
  [2,]    3    9
  
  > x["r1", ]
  c1 c2 c3
   1  4  7
  ```

* 연산

  ```r
  > x * 2
       [,1] [,2] [,3]
  [1,]    2    8   14
  [2,]    4   10   16
  [3,]    6   12   18
  
  > x %*% x						# 행렬의 곱은 다음과 같이 실행
       [,1] [,2] [,3]
  [1,]   30   66  102
  [2,]   36   81  126
  [3,]   42   96  150
  
  > (x <- matrix(c(1, 2, 3, 4, 5, 6), ncol=3))
       [,1] [,2] [,3]
  [1,]    1    3    5
  [2,]    2    4    6
  > nrow(x)					#행의 수
  [1] 2
  > ncol(x)					#열의 수
  [1] 3
  
  > dim(x)					# 차원
  [1] 2 3
  ```

  * 전치행렬 : t()
  * 역행렬 : solve()

  

#### 배열

> 다차원의 데이터

예시

```r
> (x <- array(1:12, dim=c(2, 2, 3)))
, , 1
     [,1] [,2]
[1,]    1   3
[2,]    2   4

, , 2
     [,1] [,2]
[1,]    5   7
[2,]    6   8

, , 3
     [,1] [,2]
[1,]    9   11
[2,]   10   12
```



#### 데이터 프레임

> 엑셀의 스프레드 시트와 비슷, 가장 많이 사용된다.

* 생성

  ```r
  > d1 <- data.frame(name=c("kim", "lee", "seo"),
  +                  ko=c(90,80,98),
  +                  en=c(100,78,92),
  +                  ma=c(99,69,88))
  > d1
    name ko  en ma
  1  kim 90 100 99
  2  lee 80  78 69
  3  seo 98  92 88
  
  > str(d1)
  'data.frame':	3 obs. of  4 variables:
   $ name: Factor w/ 3 levels "kim","lee","seo": 1 2 3
   $ ko  : num  90 80 98
   $ en  : num  100 78 92
   $ ma  : num  99 69 88
  ```

* 수정, 가공

  ```r
  > dname <- d1$name				#d$colname 으로 접근하여 수정, 가공
  > dname
  [1] kim lee seo
  Levels: kim lee seo
  
  > dko <- d1$ko
  > mean(dko)
  [1] 89.33333
  
  > d1$ko <- c(100,90,99)
  > d1
    name  ko  en ma
  1  kim 100 100 99
  2  lee  90  78 69
  3  seo  99  92 88
  
  > d1$si <- c(90,80,89)
  > d1
    name  ko  en ma si
  1  kim 100 100 99 90
  2  lee  90  78 69 80
  3  seo  99  92 88 89
  
  > d1$ko[c(1,2)]
  [1] 100  90
  
  > d1[,c("ko")]					# 벡터로 반환
  [1] 100  90  99
  
  > d1[,c("ko"),drop=F]			# 데이터 프레임 형식으로 반환
     ko
  1 100
  2  90
  3  99
  
  > d1[, names(d1) %in% c("ko", "si")]		# 검색과 혼합할 수 있다.
     ko si
  1 100 90
  2  90 80
  3  99 89
  ```

  



