## 알고리즘의 분석과 차수

* 정확성 분석: 모든 입력 사례에 대해서 정확한 해답을 찾는다는 것을 증명

* 효율성 분석: 입력 크기가 커지는 정도에 따라 성능의 변화량을 증명
  * **시간 복잡도**(time complexity): 시간을 기준으로 알고리즘의 효율성 분석
  * 공간 복잡도(space complexity): 공간을 기준으로 알고리즘의 효율성 분석



#### 왜 복잡도?

> 퍼포먼스는 컴퓨터의 성능이나 프로그래밍 언어에 따라 달라진다.

* 복잡도 분석: 컴퓨터나 프로그래밍 언어와 무관하게 성능 분석
  * 입력 크기에 따른 단위 연산의 실행 횟수 세기
  * 입력 크기: 문제가 가진 파라미터, 즉, 입력 사례의 크기
  * 단위 연산: 알고리즘 실행의 기본이 되는 명령어들의 집합



#### 시간 복잡도 분석

* 배열 원소의 합의 시간 복잡도 분석
  * 단위 연산: 리스트의 원소를 result에 더하는 명령
  * 입력 크기: 리스트 𝑆의 원소 개수(𝑛)
  * for 문장은 항상 𝑛번 실행하므로 다음과 같이 표현 ⁃ 시간 복잡도: 𝑇(𝑛) = 𝑛
  
* 교환 정렬의 시간 복잡도 분석
  * 단위 연산: S[i]와 S[j]의 비교
  * 입력 크기: 정렬할 리스트 𝑆의 원소 개수(𝑛)
  * for-j 루프는 i에 따라 𝑛 − 1번에서 1번까지 실행하므로 다음과 같이 계산
  * 시간 복잡도: 𝑇 (𝑛 )= 𝑛 − 1 + 𝑛 − 2 + ⋯ + 1 = (𝑛−1) 𝑛 /2

* 행렬 곱셈의 시간 복잡도 분석

  * 단위 연산: 가장 안쪽 for 루프에 있는 곱셈

  * 입력 크기: 행과 열의 개수(𝑛) 

  * 3중 for 루프가 항상 𝑛번 실행하므로 다음과 같이 계산

  * 시간 복잡도: 𝑇 (𝑛 )= 𝑛 × 𝑛 × 𝑛 = n^3

  

* 입력 사례에 따른 시간 복잡도 분석

  * 일정 시간 복잡도: 입력 사례에 따라 달라지지 않는 경우
  * **최악**, 최적, 평균 시간 복잡도 분석: 입력 사례에 따라 달라지는 경우
  
  * 순차 탐색의 시간 복잡도 분석
    * 단위 연산: 리스트의 원소와 주어진 키 𝑥와의 비교 연산 
    * 입력 크기: 리스트 원소의 개수(𝑛)
    * 최악의 경우는 모두 비교: 𝑊(𝑛) = 𝑛
    * 최적의 경우는 한 번만 비교: 𝐵(𝑛) = 1 
    * 평균의 경우: 주어진 키 𝑥가 𝑘번째에 있으면 𝑘번을 비교함: 𝐴 (𝑛) = (n + 1)/2



#### 궁극적으로 더 빠른 알고리즘

* 차수(Order): 알고리즘의 궁극적인 성능 분류
  * 1차 시간 알고리즘: 시간 복잡도가 1차 함수인 알고리즘
  * 2차 시간 알고리즘: 시간 복잡도가 2차 함수인 알고리즘
  * 근본 원리: 모든 1차 시간 알고리즘은 궁극적으로 2차 시간 알고리즘보다 빠르다.
  * 따라서, 시간 복잡도 함수의 차수로 알고리즘의 성능을 분류할 수 있다



* 알고리즘의 성능을 차수로 분류하는 법
  * 복잡도 함수를 분류할 때 낮은 차수의 항들은 항상 버릴 수 있다.
  * (궁극적으로) 2차 항이 이 함수의 값을 결정하는 데 가장 중요하기 때문



* 점근적 표기법: O, Θ,Ω 
  * 빅오(O): 복잡도 함수의 점근적 상한을 표기
  * 오메가(Ω): 복잡도 함수의 점근적 하한을 표기 
  * 쎄타(Θ)=차수: 복잡도 함수의 점근적 상한과 하한을 동시에 만족

