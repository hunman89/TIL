## ë™ì  ê³„íšë²•

> ë¬¸ì œë¥¼ ë” ì‘ì€ ë¬¸ì œë¡œ ë¶„í• , ìƒí–¥ì‹ìœ¼ë¡œ ë¬¸ì œë¥¼ í•´ê²°í•œë‹¤.



#### Memoization

- ê°€ì¥ ì‘ì€ ì…ë ¥ ì‚¬ë¡€ì˜ í•´ë‹µì„ í…Œì´ë¸”ì— ì €ì¥í•˜ê³  í•„ìš”í•  ë•Œ êº¼ë‚´ ì“´ë‹¤.



#### ë¶„í• ì •ë³µë²• vs ë™ì ê³„íšë²•

* ë¬¸ì œë¥¼ ì‘ì€ ì‚¬ë¡€ë¡œ ë¶„í• í•˜ì—¬ í•´ê²°í•œë‹¤ëŠ” ì ì—ì„œ ë™ì¼
* ë¶„í• ì •ë³µ: ì¬ê·€ í˜¸ì¶œì„ í†µí•´ ë¶„í• í•˜ì—¬ ì •ë³µ (Top-Down)
* ë™ì ê³„íš: ë©”ëª¨ì´ì œì´ì…˜ì„ í†µí•´ ìƒí–¥ì‹ìœ¼ë¡œ ì •ë³µ (Bottom-Up)



#### ì´í•­ê³„ìˆ˜

> [ì •ì˜](https://ko.wikipedia.org/wiki/%EC%9D%B4%ED%95%AD_%EA%B3%84%EC%88%98#:~:text=%EC%A1%B0%ED%95%A9%EB%A1%A0%EC%97%90%EC%84%9C%2C%20%EC%9D%B4%ED%95%AD%20%EA%B3%84%EC%88%98(%E4%BA%8C,%EC%97%86%EB%8A%94)%20%EC%A1%B0%ED%95%A9%EC%9D%98%20%EA%B0%80%EC%A7%93%EC%88%98%EC%9D%B4%EB%8B%A4.)

* ì¬ê·€ì ìœ¼ë¡œ ê³„ì‚°í•  ìˆ˜ ìˆë‹¤.

  ```python
  def bin (n, k):
  	if (k == 0 or n == k):
  		return 1
  	else:
  		return bin(n - 1, k - 1) + bin(n - 1, k)
  
  ```

* ê·¸ëŸ¬ë‚˜ í•¨ìˆ˜ì˜ ì¤‘ë³µ í˜¸ì¶œì´ ë§ì•„ì§„ë‹¤.

* ìƒí–¥ì‹ ë°©ë²• = íŒŒìŠ¤ì¹¼ì˜ ì‚¼ê°í˜• íŠ¹ì§•

  ```python
  def bin2 (n, k):
  	B = [[0] * (k + 1) for _ in range(n + 1)]
  	for i in range(n + 1):
  		for j in range(min(i, k) + 1):
  			if (j == 0 or j == i):
  				B[i][j] = 1
  			else:
  				B[i][j] = B[i - 1][j - 1] + B[i - 1][j]
  	return B[n][k]
  ```

* ë¶„í• ì •ë³µì˜ ì‹œê°„ ë³µì¡ë„ âˆˆ ğ‘›ê³¼ğ‘˜ì˜ ì§€ìˆ˜ì  ë³µì¡ë„ , ë™ì ê³„íš ì˜ ì‹œê°„ ë³µì¡ë„ âˆˆ Î˜ (ğ‘›ğ‘˜)

* ê°œì„ 

  ```python
  def bin3 (n, k):
  	if (k > n // 2):		# ëŒ€ì¹­ì 
  		k = n - k
  	B = [0] * (k + 1)
  	B[0] = 1
  	for i in range(1, n + 1):	# 1ì°¨ì› ë¦¬ìŠ¤íŠ¸ë§Œìœ¼ë¡œ êµ¬í˜„
  		j = min(i, k)
  		while (j > 0):
  			B[j] = B[j] + B[j - 1]
  			j -= 1
  	return B[k]
  ```

  



#### ìµœë‹¨ê²½ë¡œë¬¸ì œ

>ì£¼ì–´ì§„ ê·¸ë˜í”„ì—ì„œ **ëª¨ë“  ì •ì **ì˜ ìŒì— ëŒ€í•œ ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬í•˜ì‹œì˜¤.

* ğº = (ğ‘‰, ğ¸): ğºëŠ” ê·¸ë˜í”„, ğ‘‰ëŠ” ì •ì (vertex)ì˜ ì§‘í•©, ğ¸ëŠ” ê°„ì„ (edge)ì˜ ì§‘í•©
* ê·¸ë˜í”„ GëŠ” ë°©í–¥ì„±(directed), ê°€ì¤‘ì¹˜(weighted) ê·¸ë˜í”„ì„
* ìµœë‹¨ ê²½ë¡œëŠ” ë‹¨ìˆœ ê²½ë¡œ(simple path): ê°™ì€ ì •ì ì„ ë‘ ë²ˆ ê±°ì¹˜ì§€ ì•ŠìŒ



* ë‹¨ìˆœ = O(n!)
* ìµœë‹¨ê²½ë¡œë¬¸ì œëŠ” ìµœì í™”ë¬¸ì œ: í•´ë‹µí›„ë³´ì¤‘ì—ì„œ ê°€ì¥ ìµœì ì˜ ê°’.



* ê·¸ë˜í”„ì˜ í‘œí˜„ : ì¸ì ‘í–‰ë ¬
  
  * í–‰ê³¼ ì—´ì€ ì •ì , í–‰ì—´ì˜ ê°’ì€ ê°€ì¤‘ì¹˜
* 1ë‹¨ê³„ : ì¬ê·€ ê´€ê³„ì‹?
  * ğ‘«: ê° ì •ì ì˜ ìŒì´ ê°€ì§€ëŠ” ìµœë‹¨ ê²½ë¡œì˜ ê¸¸ì´ë¥¼ ë‚˜íƒ€ë‚´ëŠ” í–‰ë ¬

  * ğ‘«[i]\[j]: ğ‘£ğ‘–ì—ì„œ ğ‘£ğ‘—ë¡œ ê°€ëŠ” ìµœë‹¨ ê²½ë¡œì˜ ê¸¸ì´

  * ëª©í‘œ: ì¸ì ‘ í–‰ë ¬ ğ‘Šì—ì„œ ìµœë‹¨ ê²½ë¡œì˜ í–‰ë ¬ ğ·ì™€ì˜ ì¬ê·€ ê´€ê³„ì‹ êµ¬í•˜ê¸°

  * ğ· (0) = ğ‘Š, ğ· (ğ‘˜)ëŠ” ğ· (ğ‘˜âˆ’1)ë¡œë¶€í„° êµ¬í•¨ (1 â‰¤ ğ‘˜ â‰¤ ğ‘›)

  * ğ·(ğ‘˜) [ğ‘–] [ğ‘—]: ë‹¤ìŒê³¼ ê°™ì€ ë‘ ê°€ì§€ì˜ ê²½ìš°ë¥¼ ê³ ë ¤

    * ê²½ìš° 1: í•˜ë‚˜ì˜ ì •ì ì„ ë” ì§€ë‚˜ê²Œ í•´ ì¤˜ë„ ìƒˆë¡œìš´ ìµœë‹¨ ê²½ë¡œê°€ ì—†ëŠ” ê²½ìš°

      ğ·(ğ‘˜)[ğ‘–]\[ğ‘—] = ğ· (ğ‘˜âˆ’1) [ğ‘–] [ğ‘—] 

    * ê²½ìš° 2: í•˜ë‚˜ì˜ ì •ì (ğ‘£ğ‘˜)ì„ ë” ì§€ë‚˜ë©´ ìƒˆë¡œìš´ ìµœë‹¨ ê²½ë¡œê°€ ìˆëŠ” ê²½ìš°

      ğ· (ğ‘˜) [ğ‘–] [ğ‘—] = ğ· (ğ‘˜âˆ’1) [ğ‘–] [ğ‘˜] + ğ· (ğ‘˜âˆ’1) [ğ‘˜] [ğ‘—] 

  * ì¬ê·€ì‹ : ğ· (ğ‘˜) [ğ‘–] [ğ‘—] = min( ğ· (ğ‘˜âˆ’1) [ğ‘–] [ğ‘—] , ğ· (ğ‘˜âˆ’1) [ğ‘–] [ğ‘˜] + ğ· (ğ‘˜âˆ’1) [ğ‘˜] [ğ‘—])

```python
def floyd (W):
	D = W
	n = len(W)
	for k in range(n):			# ëª¨ë“  ì •ì ì„ ê³ ë ¤ : ì—°ê²°ì•ˆëœ ê³³ì— ë§¤ìš° í°ìˆ˜ë¥¼ ë„£ìœ¼ë©´ ë¨
		for i in range(n):
			for j in range(n):
				D[i][j] = min(D[i][j], D[i][k] + D[k][j])
	return D
```



* ìµœë‹¨ê²½ë¡œëŠ”?

  * ìƒˆë¡œìš´ í–‰ë ¬ì— ê¸°ë¡

    ```python
    def floyd2 (W):
    	n = len(W)
    	D = W
    	P = [[-1] * n for _ in range(n)]	# ì¤‘ê°„ ì •ì ì„ ê¸°ë¡í•œë‹¤. ê¸°ë³¸ -1
    	for k in range(n):
    		for i in range(n):
    			for j in range(n):
    				if (D[i][j] > D[i][k] + D[k][j]):
    					D[i][j] = D[i][k] + D[k][j]
    					P[i][j] = k
    	return D, P
    ```

  * ğ‘· [ğ’Š] [ğ’‹] = âˆ’1ì´ë©´, ê°„ì„  (ğ‘£ğ‘– , ğ‘£ğ‘—)ê°€ ìµœë‹¨ ê²½ë¡œì„

  * ğ‘· [ğ’Š] [ğ’‹] = ğ‘˜ ì¸ ê²½ìš°ì—ëŠ” inorder íƒìƒ‰

    * (ğ‘£ğ‘– , ğ‘£ğ‘˜)ì˜ ìµœë‹¨ ê²½ë¡œ ì¶œë ¥ í›„
    * ğ‘£ğ‘˜ë¥¼ ì¶œë ¥í•˜ê³ 
    * (ğ‘£ğ‘˜, ğ‘£ğ‘—)ì˜ ìµœë‹¨ ê²½ë¡œ ì¶œë ¥

    ```python
    def path (P, u, v):
    	if (P[u][v] != -1):
    		path(P, u, P[u][v])
    		print('v%d'%(P[u][v]), end='-> ')
    		path(P, P[u][v], v)
    ```

    



#### ì—°ì‡„í–‰ë ¬ê³±ì…ˆ

> ì—°ì‡„í–‰ë ¬ì„ ê³±í•˜ëŠ” ìµœì ì˜ ìˆœì„œ

* ìµœì í™”ë¬¸ì œ
* ì¼ë°˜ì ìœ¼ë¡œ, ğ‘– Ã— ğ‘˜ í–‰ë ¬ê³¼ ğ‘˜ Ã— ğ‘— í–‰ë ¬ì„ ê³±í•˜ë©´ ğ‘– Ã— ğ‘— í–‰ë ¬ì´ ë‚˜ì˜´
  * ì›ì†Œ ê³±ì…ˆì˜ íšŸìˆ˜: ğ‘– Ã— ğ‘˜ Ã— ğ‘—

* ë‹¨ìˆœ (Brute-Force Approach)
  * ì¹´íƒˆë€ìˆ˜ :  C(n-1)
  * ê´„í˜¸ë¥¼ ì”Œìš°ëŠ” ê°€ì§“ìˆ˜

* ê°€ì •
  * ğ‘‘ğ‘˜ë¥¼ í–‰ë ¬ ğ´ğ‘˜ì˜ í–‰ì˜ ê°œìˆ˜ë¡œ ì •í•¨ (1 â‰¤ ğ‘˜ â‰¤ ğ‘›)
  * ğ‘‘ğ‘˜âˆ’1ì€ í–‰ë ¬ ğ´ğ‘˜ì˜ ì—´ì˜ ê°œìˆ˜, ğ´ğ‘˜âˆ’1ì˜ í–‰ì˜ ê°œìˆ˜
  * ğ‘‘0ëŠ”ğ´1ì˜ ì—´ì˜ ê°œìˆ˜

* ì¬ê·€ ê´€ê³„ì‹

  * ğ‘´: ì—°ì‡„ í–‰ë ¬ì„ ê³±í•˜ëŠ”ë° í•„ìš”í•œ ê³±ì…ˆì˜ ìµœì†Œ íšŒìˆ˜ í–‰ë ¬
  * ğ‘´[ğ’Š]\[ğ’‹]: ğ´ğ‘–ì—ì„œ ğ´ğ‘—ê¹Œì§€ í–‰ë ¬ì„ ê³±í•˜ëŠ”ë° í•„ìš”í•œ ê³±ì…ˆì˜ ìµœì†Œ íšŒìˆ˜(1 â‰¤ ğ‘– â‰¤ ğ‘— â‰¤ ğ‘›)
  * ë¶„í• ì •ë³µ: ğ‘›ê°œì˜ í–‰ë ¬ì„ ë‘ ê°œì˜ ìµœì  ë¶€ë¶„í–‰ë ¬ì˜ ê³±ìœ¼ë¡œ ë¶„í• 
  * ê° ë¶„í• ì˜ ê³±ì…ˆ íšŸìˆ˜: ê° ë¶€ë¶„í–‰ë ¬ì˜ ê³±ì…ˆ íšŸìˆ˜ + ë‘ í–‰ë ¬ì˜ ê³±ì…ˆ íšŸìˆ˜
  * ğ‘€ [ğ‘–] [ğ‘—] = minimum (ğ‘€[ğ‘–] [ğ‘˜] + ğ‘€ [ğ‘˜ + 1] [ğ‘—] + ğ‘‘ğ‘–âˆ’1ğ‘‘ğ‘˜ğ‘‘ğ‘— )

  ```python
  def minmult (d):
  	n = len(d) - 1
  	M = [[-1] * (n + 1) for _ in range(n + 1)]		# -1ì„ ê¸°ë³¸ê°’ìœ¼ë¡œ í•˜ëŠ” í–‰ë ¬
  	P = [[-1] * (n + 1) for _ in range(n + 1)]
  	for i in range(1, n + 1):
  		M[i][i] = 0									# ëŒ€ê°ì„ 0ìœ¼ë¡œ
  	for diagonal in range(1, n):
  		for i in range(1, n - diagonal + 1):
  			j = i + diagonal
  			M[i][j], P[i][j] = minimum(M, d, i, j)	# ë™ì ê³„íšë²•ì ìœ¼ë¡œ ë§¤íŠ¸ë¦­ìŠ¤ì— ì±„ì›Œì§„ë‹¤.
  	return M, P
  
  def minimum (M, d, i, j):
  	minValue = INF
  	minK = 0
  	for k in range(i, j):
  		value = M[i][k] + M[k + 1][j]
  		value += d[i - 1] * d[k] * d[j]
  		if (minValue > value):
  			minValue = value
  			minK = k
  	return minValue, minK
  ```

* ê³±ì…ˆ ìˆœì„œ (P í–‰ë ¬ = k ê°’ ì €ì¥)

  * ì¬ê·€ì ìœ¼ë¡œ í˜¸ì¶œí•˜ë©´ì„œ ì°¾ì•„ë‚¸ë‹¤.

  ```python
  def order (P, i, j):
  	if (i == j):
  		print('A%d'%(i), end='')
  	else:
  		k = P[i][j]
  		print('(', end ='')
  		order(P, i, k)
  		order(P, k + 1, j)
  		print(')', end ='')
  ```

  



#### ìµœì  ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬

> ì£¼ì–´ì§„ nê°œì˜ í‚¤ë¡œ ìµœì  ì´ì§„ê²€ìƒ‰íŠ¸ë¦¬ë¥¼ êµ¬í•˜ì‹œì˜¤

* ë¬¸ì œ ì •ì˜
  * ì£¼ì–´ì§„ ğ‘›ê°œì˜ í‚¤: ğ¾1,ğ¾2, â‹¯ ,ğ¾ğ‘›
  * ê° í‚¤ì˜ ê²€ìƒ‰ í™•ë¥  ğ‘ğ‘– : ì „ì²´ ê²€ìƒ‰ íšŸìˆ˜ ì¤‘ì—ì„œ ğ¾ğ‘–ë¥¼ ê²€ìƒ‰í•˜ëŠ” í™•ë¥ 
  * ê° í‚¤ì˜ ë¹„êµ íšŸìˆ˜ ğ‘ğ‘– : ğ¾ğ‘–ë¥¼ ê²€ìƒ‰í•˜ëŠ” ë° í•„ìš”í•œ í‚¤ì˜ ë¹„êµ íšŸìˆ˜
  * ê° í‚¤ì˜ í‰ê·  ê²€ìƒ‰ ë¹„ìš©(ì‹œê°„): ê²€ìƒ‰ í™•ë¥  Ã— ë¹„êµ íšŸìˆ˜ (ğ‘ğ‘– Ã— ğ‘ğ‘– )
  * ì „ì²´ í‚¤ì˜ í‰ê·  ê²€ìƒ‰ ë¹„ìš©(ì‹œê°„): ê° í‚¤ì˜ í‰ê·  ê²€ìƒ‰ ë¹„ìš© í•©
* ì´ì§„ê²€ìƒ‰íŠ¸ë¦¬? (BST: Binary Search Tree)
  * ê° ë…¸ë“œëŠ” í•˜ë‚˜ì˜ ìœ ì¼í•œ í‚¤ë¥¼ ê°€ì§€ê³  ìˆë‹¤
  * ëª¨ë“  ë…¸ë“œê°€ ê°€ì§„ í‚¤ì˜ ê°’ì€ ê·¸ ë…¸ë“œì˜ ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬ì˜ í‚¤ì˜ ê°’ë³´ë‹¤ í¬ë‹¤
  * ëª¨ë“  ë…¸ë“œê°€ ê°€ì§„ í‚¤ì˜ ê°’ì€ ê·¸ ë…¸ë“œì˜ ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ì˜ í‚¤ì˜ ê°’ë³´ë‹¤ ì‘ë‹¤
* ë‹¨ìˆœ (Brute-Force Approach)
  * ì¹´íƒˆë€ìˆ˜ :  C(n)

* ë™ì ê³„íš : ì¬ê·€ì‹ ì°¾ê¸°
  * íŠ¸ë¦¬ ğ‘˜: í‚¤ ğ¾ğ‘˜ê°€ ë£¨íŠ¸ ë…¸ë“œì— ìˆëŠ” ìµœì  ì´ì§„ê²€ìƒ‰íŠ¸ë¦¬
  * í‚¤ ë¹„êµ íšŸìˆ˜: ì„œë¸Œ íŠ¸ë¦¬ì˜ ë¹„êµ íšŸìˆ˜ì— ë£¨íŠ¸ì—ì„œ ë¹„êµ í•œ ë²ˆ ì¶”ê°€
  * ğ‘š â‰  ğ‘˜ì¸ ğ¾ğ‘šì— ëŒ€í•´ì„œ íŠ¸ë¦¬ ğ‘˜ì— ğ¾ğ‘šì„ ë†“ê¸° ìœ„í•œ ë¹„êµ í•œ ë²ˆ ì¶”ê°€
    * ğ¾ğ‘šì˜ í‰ê·  ê²€ìƒ‰ë¹„ìš©ì— ğ‘ğ‘šì„ ì¶”ê°€
    * ğ´[1]\[ğ‘˜ âˆ’ 1]+ğ´[ğ‘˜ + 1]\[ğ‘›] + allğ‘ğ‘š

```python
def optsearchtree (p):
	n = len(p) - 1
	A = [[-1] * (n + 1) for _ in range(n + 2)]
	R = [[-1] * (n + 1) for _ in range(n + 2)]
	for i in range(1, n + 1):
		A[i][i - 1] = 0
		A[i][i] = p[i]
		R[i][i - 1] = 0
		R[i][i] = i
	A[n + 1][n] = 0
	R[n + 1][n] = 0
	for diagonal in range(1, n):
		for i in range(1, n - diagonal + 1):
			j = i + diagonal
			A[i][j], R[i][j] = minimum(A, p, i, j)
	return A, R

def minimum (A, p, i, j):
	minValue = INF
	minK = 0
	for k in range(i, j + 1):
		value = A[i][k - 1] + A[k + 1][j]
		for m in range(i, j + 1):
			value += p[m]
		if (minValue > value):
			minValue = value
			minK = k
	return minValue, minK
```

* íŠ¸ë¦¬ êµ¬í•˜ê¸° = ì¬ê·€í˜¸ì¶œì„ í†µí•œ ë¶„í• ì •ë³µ

```python
def tree (R, i, j):
    k = R[i][j]
	if (k == 0):
		return None
	else:
		node = BSTNode(keys[k])
		node.left = tree(R, i, k - 1)
		node.right = tree(R, k + 1, j)
		return node
    
class BSTNode:
	def __init__ (self, key):
		self.key = key
		self.left = None
		self.right = None
	def preorder (node):
		if (node is None):
			return
		else:
			print(node.key, end =' ')
			preorder(node.left)
			preorder(node.right)
	def inorder (node):
		if (node is None):
			return
		else:
			inorder(node.left)
			print(node.key, end =' ')
			inorder(node.right)
```





